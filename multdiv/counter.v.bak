`define state0 = 3'b000
`define state1 = 3'b001
`define state2 = 3'b010
`define state3 = 3'b011
`define state4 = 3'b100
`define state5 = 3'b101
`define state6 = 3'b110
`define state7 = 3'b111

module counter(clf, reset, w, z, present, next);
	input clk, reset, w;
	output z;
	output [2:0] present,next;
	
	
	wire [2:0] present;
	
	reg z;
	reg [2:0] next;
	
	always @(*) begin
		case(present)
			`state0: next = w ? `state0 : `state1;
			`state1: next = w ? `state0 : `state2;
			`state2: next = w ? `state0 : `state3;
			`state3: next = w ? `state0 : `state4;
			`state4: next = w ? `state0 : `state5;
			`state5: next = w ? `state0 : `state6;
			`state6: next = w ? `state0 : `state7;
			`state7: next = w ? `state0 : `state0;
			default: next = `state0;
		endcase
	end
	
	always @(present) begin
		case(present)
			`state0: z = `state0;
			`state1: z = `state1;
			`state2: z = `state2;
			`state3: z = `state3;
			`state4: z = `state4;
			`state5: z = `state5;
			`state6: z = `state6;
			`state7: z = `state7;
			default: z= `state0;
		endcase
	end

	DFF state_reg_0(.clk(clk), .d(next[0]), .q(present[0]))
	DFF state_reg_1(.clk(clk), .d(next[1]), .q(present[1]))
	DFF state_reg_2(.clk(clk), .d(next[2]), .q(present[2]))
	
endmodule